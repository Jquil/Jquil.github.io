# 前言

![](https://tse1-mm.cn.bing.net/th/id/OIP-C.P0UvgWusRNts1XRi8tc3_QHaB1?w=737&h=186&c=7&o=5&pid=1.7)

Flutter的数据存储用到了和Android一样的SQLite，但经过学习之后，发现在使用上不尽相同


# 使用步骤

## 引入依赖

第一步，先加入`sqflite & path`依赖，在`pubspec.yaml`中添加

```
dependencies:
  flutter:
    sdk: flutter
  sqflite:
  path:
```

- **sqflite**：可以便捷地操纵SQLite
- **path**：可以正确定义数据库在磁盘上的存储位置


## 定义数据模型

：用意是方便我们操纵数据

```
class Like {
  final int id;
  final String singer;
  final String song;

  Like({
    required this.id,
    required this.singer,
    required this.song,
  });

  // 将数据转换为Map类型，操纵数据库时会用到
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'singer': singer,
      'song': song,
    };
  }
}
```

## 创建数据库/表

：文件路径：`lib>db>myDB.dart`
```
import 'dart:async';
import 'package:flutter/widgets.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

void main() async {
  
  WidgetsFlutterBinding.ensureInitialized();
  final database = openDatabase(                // 1
    
    // 设置数据库的路径。注意：使用 `path` 包中的 `join` 方法
    join(await getDatabasesPath(), 'music.db'), // 2
    
    // 当数据库第一次被创建的时候，创建数据表
    onCreate: (db, version) {
      return db.execute(
        'CREATE TABLE like(id INTEGER PRIMARY KEY, singer TEXT, song TEXT)',
      );
    },
    
    // 设置版本。它将执行 onCreate 方法，同时提供数据库升级和降级的路径。
    version: 1,
  );

```


## 增删查改

我们新增一个文件：`lib>db>tb>like.dart`，里面使用增删查改方法

\> 增
```
Future<void> insertLike(Like like) async {
   await db.insert(
    'like',
    like.toMap(),
    conflictAlgorithm: ConflictAlgorithm.replace,
  );
}

===> 调用
var song = Like(
  id: 1,// 应该可以不用加
  singer: 'Jq',
  song: '海底',
);

await insertDog(song);
```

<br/>

\> 删

```
Future<void> deleteById(int id) async{
    await db.delete(
        "like",
        where:'id = ?',
        wereArgs:[id]
    )
}
```


<br/>

\> 查
```
Future<List<Like>> queryBySinger(String singer) async {
    List<Map> list = await db.rawQuery('select * from like where singer = ' + singer);
    return List.generate(list.length, (i) {
        return Like(
            id:     list[i]['id'],
            singer: list[i]['singer'],
            song:   list[i]['song']
        );
    });
}

```


<br/>

\> 改

```
Future<void> updateById(Like like) async{
    await db.update(
        "like",
        like.toMap(),
        where:'id = ?',
        whereArgs:[like.id]
    )
}
```


# 其他

## 异步编程

Flutter程序是用Dart语言编写，而Dart是单线程语言，因此需要通过异步编程提高效率

其中上面接触到的Future对象，async/await关键字都是实现了异步

1. `async` 标明函数是异步函数

1. `await` 等待执行完成，阻塞后面代码

1. `Future` 函数返回Future对象标识：异步操作返回的结果，通过`then`取出结果并处理

学习：[Flutter中的异步（Future、async、await、FutureBuilder）和 网络请求](https://blog.csdn.net/yuzhiqiang_1993/article/details/89155870)


<br/>

## 单例

没什么不同，注意一下语法即可。

详情请查看：[flutter 类单例模式](https://blog.csdn.net/weixin_43294560/article/details/108480176)

# 小结

这里附上：[Flutter:用SQLite做数据持久化](https://flutter.cn/docs/cookbook/persistence/sqlite)

此外也可以使用ORM，但还没尝试过，具体可以看看：[手把手教你在Flutter项目优雅的使用ORM数据库](https://www.jianshu.com/p/62500ae08a07)
# 前言



本节主要学习以下部分内容：

【1】基本操作（distinct、top、EXISTS、group by、order by、having 使用）

【2】左连接、右连接、内连接

【3】事务

【4】视图

【5】自定义函数

【6】存储过程

【7】触发器

【6】SQL优化


# 基本操作


# 连接


# 事务


# 视图


# 自定义函数


# 存储过程


# 触发器


# SQL优化

测试效率？


# 小结

附上学习文章：

[sql server 基础教程[温故而知新三]](read://https_www.cnblogs.com/?url=https%3A%2F%2Fwww.cnblogs.com%2Ftoutou%2Fp%2F4733670.html)

[SQL Server进阶（11）存储过程](read://https_www.cnblogs.com/?url=https%3A%2F%2Fwww.cnblogs.com%2Fcnki%2Fp%2F9520338.html)

[sql server之数据库语句优化](read://https_www.cnblogs.com/?url=https%3A%2F%2Fwww.cnblogs.com%2Ftoutou%2Farchive%2F2013%2F04%2F14%2F4427351.html)

------------ 旧内容 ----------------------

# 安装

emmmm，安装教程具体看这篇：[SQL-Server2008 R2 图文安装教程](https://blog.csdn.net/zhaidada01/article/details/110915499)


# Join

：用于多表连接操作


## Inner Join

只有满足匹配条件才返回行：
```
select tb_child.name,tb_parent.pather_name from tb_child,tb_parent
where tb_child.father_id = tb_parent.father_id

等同于以下查询语句：↓

select tb_child.name,tb_parent.pather_name from tb_child
inner join tb_parent on tb_child.father_id = tb_parent.father_id
```
：参考文章 => [W3School：Inner Join](https://www.w3school.com.cn/sql/sql_join_inner.asp)

<br>

## Left Join

：返回左表所有显示的字段数据，匹配右表满足条件的数据

```
select tb_child.name,tb_parent.pather_name from tb_child
left join tb_parent
on tb_child.farther_id = tb_parent.farther_id

// LEFT JOIN 关键字会从左表返回所有的行，即使在右表中没有匹配的行。
即：获取tb_child显示的字段，以及匹配tb_parent字段
```

：参考文章 => [W3School：Left Join](https://www.w3school.com.cn/sql/sql_join_left.asp)

<br>

## Right Join

```
select tb_child.name,tb_parent.pather_name from tb_child
right join tb_parent
on tb_child.farther_id = tb_parent.farther_id

：与left join相反：返回tb_parent所有显示的字段，匹配tb_child字段
```

：参考文章 => [W3School：Right Join](https://www.w3school.com.cn/sql/sql_join_right.asp)

<br>

## Union

\> **合并多个Select结果集**

Union 会合并结果集，但不合并重复的结果集

Union All 则会合并重复结果集（这里的结果集对应的是字段）

：参考文章 => [W3School：Union](https://www.w3school.com.cn/sql/sql_union.asp)

<br>

# 存储过程

## declare
声明变量的修饰符
```
Declare @name nvarchar(50)
```

## output
output的作用：相当于地址传递

：将参数（地址）传递给存储过程，存储过程执行过程中修改了参数（地址），那么最后势必也会影响到我们的参数。


## 选择
SQL中可以使用if-else(不知道else if是否可用)，以及case-when-end(不需要switch)
```
if @name = 'Jq'
begin
    // todo
end
else
begin
    // todo
end
```

&&

```
set @name = 
        case @age
            when 18 then 'Jq18'
            when 19 then 'Jq19'
        end
```

放上一个示例
```
-- 创建存储过程，并定义参数
create proc [dbo].[getSignPeople] @deptid nvarchar(25)
as 
begin
	-- 定义变量
	declare @id int
	declare @name nvarchar(100)
	if(@deptid = '1')
		begin
			-- 定义游标
			declare cur cursor for select name from tbPerson
			open cur
			-- into：如果sql=select * from table，则需要into @coulumn1,@column2...
			Fetch Next from cur into @name
			-- 遍历
			while(@@fetch_status = 0)
				begin
					select @name
					Fetch Next from cur into @name
				end

			close cur
		end
end
```





## 循环

可以用递归的方式，此外还可以使用while循环
```
while(...)
begin
    // todo
end
```


# 触发器


定义一个触发器：

```
create trigger insert_trigger
on tbPerson (表)
for insert	(触发事件)
as
declare @name varchar(50)
select @name = name from inserted
insert into tbPerson_1(name) values(@name)
```


[查看当前数据库中的触发器](https://www.cnblogs.com/davidhou/p/5846914.html)：首先在SQL-Server左上角数据库切换到自己的数据库，再执行SQL语句

```
--查看当前库中所有的触发器:
SELECT * FROM Sysobjects WHERE xtype = 'TR'

--查看当前库中所有的触发器和与之相对应的表：
SELECT tb2.name AS tableName,tb1.name AS triggerName FROM Sysobjects tb1 JOIN Sysobjects tb2 ON tb1.parent_obj=tb2.id WHERE tb1.type='TR'

--显示触发器的定义:
EXEC sp_helptext '触发器名'

--查看触发器的有关信息:
EXEC sp_help '触发器名'

--查看表中的触发器类型:
EXEC sp_helptrigger '表名'
```

查看：[关于获取刚添加进数据表的数据](https://blog.csdn.net/tmy_starlight/article/details/106312228)


最后是关于触发器的修改与删除：
```
// 修改
alter trigger insert_trigger
on tbPerson
for insert
as 
declare @name varchar(50)
select @name = name from inserted
set @name = len(@name)
insert into tbPerson_1(name) values(@name)

// 删除
drop trigger insert_trigger
```

查看：[关于修改触发器内容](https://www.cnblogs.com/liuqiyun/p/8603088.html)


关于触发器，我们还可以点击数据表，展开二级菜单，里面也有触发器的选项。

# 小结

数据库知识，其实处于应用层层面大致都相同，无非就是增删查改、存储过程、触发器等，不同的数据库可能还会提供一些独有的函数

再高级一点，就是优化查询语句。

OK，本文先到这，拜了个拜~
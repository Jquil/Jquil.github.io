# 前言

看了一些文章，人脸识别的实现方式其实还蛮多种的，这里我通过以下步骤来实现：

1. 深度学习训练模型（人像图片）

2. opencv实现人像检测

3. 最后匹配模型是否一致

# 物品识别

在开始之前呢，我们先跟着[文章](https://blog.csdn.net/jimtien/article/details/118929804)跑一跑程序，熟悉一下这个识别的过程，我们需要准备以下文件：

- [bvlc_googlenet.caffemodel](http://dl.caffe.berkeleyvision.org/bvlc_googlenet.caffemodel)

- [bvlc_googlenet.prototxt](https://github.com/opencv/opencv_extra/blob/master/testdata/dnn/bvlc_googlenet.prototxt)

- [classification_classes_ILSVRC2012.txt](https://github.com/opencv/opencv/blob/master/samples/data/dnn/classification_classes_ILSVRC2012.txt)

- 几张飞机、蝴蝶...图片

同样放在启动目录下（Application.StartupPath）：`project\bin\Debug`

OK，我们新建一个WindForm项目，安装 **OpenCVSharp4**，并为窗体添加一个Button控件

```
using System.IO;
using System.Linq;
using OpenCvSharp;
using OpenCvSharp.Dnn;

namespace demo{

    public partial class Form1 : Form {
        
        int rszWidth = 224, rszHeight = 244;
        float scale = 1;

        Scalar mean = new Scalar(104,117,123),
               std  = new Scalar(0.0,0.0,0.0); 

        bool swapRB = true,     // OpenCV中认为我们的图片通道顺序是BGR，但是我平均值假设的顺序是RGB，所以如果需要交换R和G，那么就要使swapRB=true
             crop   = false;

        int inpWidth  = 224,
            inpHeight = 164;

        String model   = Application.StartupPath + "\\bvlc_googlenet.caffemodel";,
               config  = Application.StartupPath + "\\bvlc_googlenet.prototxt",
               classf  = Application.StartupPath + "\\classification_classes_ILSVRC2012.txt",
               picFile = Application.StartupPath + "\\bird.jpg";
        
        int backendId = 0,  // auto
            targetId  = 0;  // cpu

        var class = [];

        Net net;

        public Form1(){
            InitializeComponent();
            init();
        }

        privoid void init(){

            // 将类别转化为数组形式
            class = File.readAllLines(classf)
                        .Select(line => line.split(' ').Last())
                        .ToArray();

            // readNet() => 加载模型和权重
            net = Net.readNet(model,config);

            // GPU加速
            net.setPreferableBackend(Backend.OPENCV);
            net.setPreferableTarget(Target.CPU);
        }

        private void Button1_Click(object sender, EventArgs e){
            String wname = "deep learning";
            Cv2.NamedWindow(wname,WindowFlags.Normal);

            // Mat => 将图像转为矩阵形式
            Mat frame = new Mat(picFile),
                blob  = new Mat();
            
            if(frame.isEmpty())
                return;
            
            if(rszWidth != 0 && rszHeight != 0){
                Cv2.Resize(frame,frame,new Size(rszWidth,rszHeight));
                inpWidth  = rszWidth;
                inpHeight = resHeight;
            }

            // 对图像进行预处理，包括减均值，比例缩放，裁剪，交换通道等，返回一个4通道的blob(blob可以简单理解为一个N维的数组，用于神经网络的输入)
            blob = CvDnn.BlobFromImage(frame,scale,new Size(inpWidth,inpHeight),mean,swapRB,crop);

            if(std.Val0 != 0.0 && std.Val1 != 0.0 && std.Val2 != 0.0){
                Cv2.Divide(blob,std,blob);
            }

            // 设置网络输入
            net.SetInput(blob);

            // 这个函数只需要提供layer的name即可；函数返回一个Mat变量，返回值是指输入的layername首次出现的输出。默认输出整个网络的运行结果。
            Mat prob = net.Forward();

            Point  classIdPoint, minLoc;
            double confidence, minVal;

            // 求这个矩阵的最小值，最大值，并得到最大值，最小值的索引
            Cv2.MinMaxLoc(prob.Reshap(1,1),out minVal, out confidence, out minLoc, out classIdPoint);
            
            int cId = classIdPoint.X;
            double[] layersTime;
            double freq = Cv2.GetTickFrequence() / 10000,
                   t    = net.GetPerfProfile(out layersTime) / freq;

            // 输出
            String label = String.Format("Inference Time:{0:00.0}ms",t);
            Cv2.putText(frame,label,new Point(0,15),HersheyFonts.HersheySimplex,0.5,new Scalar(0,0,255));
            label = String.Format("{0}:{1:0.000}",class[cId],confidence);
            Cv2.putText(frame,label,new Point(0,40),HersheyFonts.HersheySimplex,0.5,new Scalar(0,0,255));
            Cv2.ImShow(wname,frame);
            Cv2.WaitKey();
        }
    }
}
```

最终实现效果如下：

<div align='center'>

我是效果图
</div>


实现了效果，现在我们来理解一下代码的执行，首先是代码开始引入的三个文件：

- **classification_classes_ILSVRC2012.txt**：里面储存的都是各种识别目标（名字）

- **bvlc_googlenet.prototxt**：网络结构文件

- **bvlc_googlenet.caffemodel**：训练好的模型


OK，然后我们来解读一下整体思路：

1. 加载模型与权重

2. 将图像转为矩阵形式

3. 对图像预处理，设置网络输入

4. 调用`forward()`：输出整个网络的运行结果




# 训练模型


回到我们的需求中来，我们第一步操作应该是训练模型

深度学习的框架同样有很多种，为了配合opencv的使用，这里采用 「**caffe**」

## 安装 Caffe

首先我们需要安装Caffe深度学习框架，教程如：[实践详细篇-Windows下使用VS2015编译安装Caffe环境(CPU ONLY)](https://www.cnblogs.com/david97/p/8949713.html)

1。[安装cmake](https://blog.csdn.net/duoduohair/article/details/116295919)，并配置环境变量，cmd：`cmake -version`判断是否安装成功

2。[安装python](https://www.python.org/downloads/)，并cmd：`python`判断是否安装成功（注意，python版本最好与Anaconda的版本一致）

3。 安装python模块：
- [Anaconda](https://www.anaconda.com/download/) => [Anaconda版本需要与python版本对应](https://blog.csdn.net/yuejisuo1948/article/details/81043823)
- [pip](https://zhuanlan.zhihu.com/p/38603105)，cmd：`pip list`检测是否安装成功

4。pip安装six、yaml、numpy：
```
pip install six
pip install pyyaml
pip install numpy
```

5。Visual Studio 添加 C++支持：[安装VS后如何再添加新的编程组件?](https://blog.csdn.net/qq_34463441/article/details/87931495)

6。安装caffe：[下载](https://github.com/BVLC/caffe.git) 并跟随上述教程中的配置进行修改


编译：`D:\Caffe\scripts>start build_win.cmd`


## 数据格式转化

> 我们在使用Caffe做深度学习项目时，经常需要制作Caffe常用的数据类型lmdb、leveldb以及hdf5等（尽管可以使用原始图片，但是效率低）

因此，我们来学习一下如何实现数据格式的转化

文件夹结构：

<div align='center'>


![](https://img2018.cnblogs.com/blog/1423648/201904/1423648-20190409173441363-1153633012.png)
</div>


emmmm，文章是以猫和狗来做例子，那么我们就拿孙燕姿和周杰伦来作例子好了（就将dog -> 周杰伦，cat -> 孙燕姿）

最后整理如下：

<div align='center'>

附上整理后的文件夹结构图

</div>

最后再制造train.txt和val.txt文件（就在数据集的根目录下）

<div align='center'>

文件详情
</div>


最后，我们在根目录下新建一个bat文件并编辑内容：
```
D:\caffe\Build\x64\Release\convert_imageset.exe --gray --resize_width=144 --resize_height=144   ./train/ train.txt  train_lmdb -backend=lmdb
D:\caffe\Build\x64\Release\convert_imageset.exe --gray --resize_width=144 --resize_height=144   ./val/ val.txt  val_lmdb -backend=lmdb
pause
```

双击运行就会自动生成拉~

贴上：[Windows10制作LMDB详细教程](https://www.cnblogs.com/xiaoboge/p/10678658.html)

## 网络结构文件

编写网络结构文件：`struct.prototxt` => 编写网络有多少层，每一层有多少个特征图，输入、输出...

我们需要修改其中的训练层，测试层的图片路径

```
name: "LeNet"

// 训练层
layer {  
  name: "mnist"  
  type: "Data"          // data层  
  top: "data"  
  top: "label"  
  include {  
    phase: TRAIN        // 训练阶段  
  }  
  transform_param {  
    scale: 0.00390625   //对所有的图片归一化到0~1之间，也就是对输入数据全部乘以scale，0.0039= 1/255  
  }  
  data_param {  
    source: "person/mnist/mnist_train_lmdb"  // 训练数据图片路径  
    batch_size: 64      // 每次训练采用的图片64张，min-batch  
    backend: LMDB  
  }  
} 

// 测试层
layer {  
  name: "mnist"  
  type: "Data"  
  top: "data"  
  top: "label"  
  include {  
    phase: TEST                                 // 测试  
  }  
  transform_param {  
    scale: 0.00390625  
  }  
  data_param {  
    source: "examples/mnist/mnist_test_lmdb"    // 测试数据图片路径
    batch_size: 100  
    backend: LMDB  
  }  
}

layer {  
  name: "conv1"         // 卷积神经网络的第一层，卷积层  
  type: "Convolution"   // 这层操作为卷积  
  bottom: "data"        // 这一层的前一层是data层  
  top: "conv1"
  param {  
    lr_mult: 1     
  }  
  param {  
    lr_mult: 2  
  }  
  convolution_param {  
    num_output: 20    // 定义输出特征图个数  
    kernel_size: 5    // 定义卷积核大小  
    stride: 1  
    weight_filler {  
      type: "xavier"  
    }  
    bias_filler {  
      type: "constant"  
    }  
  }  
}

// 池化层
layer {  
  name: "pool1"  
  type: "Pooling"       // 池化层，这一层的操作为池化  
  bottom: "conv1"       // 这一层的前面一层名字为：conv1  
  top: "pool1"  
  pooling_param {  
    pool: MAX           // 最大池化  
    kernel_size: 2  
    stride: 2  
  }  
}  
layer {  
  name: "conv2"  
  type: "Convolution"  
  bottom: "pool1"  
  top: "conv2"  
  param {  
    lr_mult: 1  
  }  
  param {  
    lr_mult: 2  
  }  
  convolution_param {  
    num_output: 50  
    kernel_size: 5  
    stride: 1  
    weight_filler {  
      type: "xavier"  
    }  
    bias_filler {  
      type: "constant"  
    }  
  }  
}  
layer {  
  name: "pool2"  
  type: "Pooling"  
  bottom: "conv2"  
  top: "pool2"  
  pooling_param {  
    pool: MAX  
    kernel_size: 2  
    stride: 2  
  }  
}  
layer {  
  name: "ip1"  
  type: "InnerProduct"  
  bottom: "pool2"  
  top: "ip1"  
  param {  
    lr_mult: 1  
  }  
  param {  
    lr_mult: 2  
  }  
  inner_product_param {  
    num_output: 500  
    weight_filler {  
      type: "xavier"  
    }  
    bias_filler {  
      type: "constant"  
    }  
  }  
}  
layer {  
  name: "relu1"  
  type: "ReLU"  
  bottom: "ip1"  
  top: "ip1"  
}  
layer {  
  name: "ip2"  
  type: "InnerProduct"  
  bottom: "ip1"  
  top: "ip2"  
  param {  
    lr_mult: 1  
  }  
  param {  
    lr_mult: 2  
  }  
  inner_product_param {  
    num_output: 10  
    weight_filler {  
      type: "xavier"  
    }  
    bias_filler {  
      type: "constant"  
    }  
  }  
}  
layer {  
  name: "accuracy"  
  type: "Accuracy"  
  bottom: "ip2"  
  bottom: "label"  
  top: "accuracy"  
  include {  
    phase: TEST  
  }  
}  
layer {  
  name: "loss"  
  type: "SoftmaxWithLoss"  
  bottom: "ip2"  
  bottom: "label"  
  top: "loss"  
}
```



## 网络求解文件

编写网络求解文件：`solver.prototxt` => 主要包含了一些求解网络，梯度下降参数、迭代次数等参数...


```
net: "person/mnist/lenet_train_test.prototxt"       // 修改为刚刚创建的网络结构文件的路径

test_iter: 100   
  
test_interval: 500      // 每隔500次用测试数据，做一次验证  
  
base_lr: 0.01           // 学习率  
momentum: 0.9           // 动量参数  
weight_decay: 0.0005    // 权重衰减系数  
  
lr_policy: "inv"        // 梯度下降的相关优化策略  
gamma: 0.0001  
power: 0.75  
  
display: 100  
  
max_iter: 10000                         // 最大迭代次数  
  
snapshot: 5000                          // 每迭代5000次，保存一次结果  
snapshot_prefix: "examples/mnist/lenet" // 保存结果路径  
  
solver_mode: CPU                        // 训练硬件设备选择GPU还是CPU
```

## 训练与测试

我们cmd切换到`caffe/build/tools` 目录下

执行：`caffe train --solver=D:/person/solver.prototxt`

执行完成后就会生成caffemodel的文件~

最后我们来测试一下准确率：

同样切换到`caffe/build`目录下，执行 `caffe.exe test -model=D:/person/solver.prototxt -widgets=D:/person/person.caffemodel`

<div align='center'>

贴上准确率~
</div>


[Caffe初学入门](https://cxybb.com/article/Touch_Dream/78669236)

[用caffe跑自己的数据，基于WINDOWS的caffe](https://www.cnblogs.com/love6tao/p/5743030.html)

# 实现

OK，前期准备工作都已经完成了，现在正式开始我们的需求：实现人脸识别！

新建一个WinForm项目，并安装：`opencvsharp4`，以及将person文件拷贝到启动目录下~


```

```

最终实现效果图如下：

<div align='center'>

我是效果图
</div>
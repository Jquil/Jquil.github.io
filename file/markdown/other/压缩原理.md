# 前言

在软件开发过程中，当请求/响应数据过大会导致传输时间久，响应慢，这时候我们可以会对数据进行压缩，这一节我们就来研究压缩这个过程发生了什么；


# deflate

压缩本质去除数据中的冗余信息：对于这么一个字符串'abababababab'，当使用utf8编码时所占12个字节(一个字符占一个字节)，字符串中包含6个'ab'，如果我们使用'6ab'来表示，那么只需要3个字节即可；

### lz77

lz77思想和上面压缩思想有些相似，以这个字符串为例：'hello,world!hello,michelle!'，我们可以知道'hello,'出现了两次，那么在重复出现的时候我们可以使用'(offset,len)'方式来代替：这个可以用'指针'概念来理解，指针指向前一个'hello,'首字符的位置，然后读取len个字符；

因此，当数据内重复信息越多，重复内容越长，压缩率越高；


### huffman

buffman压缩思想则是用较短的位数来表示较长的字节，还是以'hello,world!hello,michelle!'为例，我们使用以下代码输出各自字符出现的次数：
```csharp
var content = "hello,world!hello,michelle!";
var pairs = new Dictionary<char, int>();
foreach(var ch in content.ToCharArray())
{
    if (pairs.ContainsKey(ch)) pairs[ch]++;
    else pairs.Add(ch, 1);
}
var list = pairs.ToList().OrderByDescending(kvp => kvp.Value).ToList();
foreach(var kvp in list)
{
    Console.WriteLine($"code={((byte)kvp.Key).ToString().PadLeft(3,'0')},ch='{kvp.Key}',len={kvp.Value}");
}
```
<div align='center'>

信息截图
</div>

我们可以利用上面的信息编织一颗二叉树：
<div align='center'>


</div>


精简重复字符长度


# 小结

[1] [你还不懂ZIP压缩的原理？一条视频讲清楚ZIP算法中的LZ77编码](https://www.bilibili.com/video/BV18Q4y1d7Kt)

[2] [哈夫曼编码很难懂？一条视频讲清楚](https://www.bilibili.com/video/BV1c64y1r7Sc)

[3] [zlib压缩原理](https://www.bilibili.com/video/BV1XR4y1e7DH) | [CSDN](https://blog.csdn.net/dovakejin/article/details/129096962)

